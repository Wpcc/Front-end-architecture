# 前端

## HTML

- src 和 href 的区别
- 页面引入外部脚本时，`defer`和`async`的区别
- 本地存储 localStorage 和 sessionStorage 的区别

## CSS

- 什么是 CSS 盒模型？标准盒模型和 IE 盒模型有哪些区别？
- 什么是 BFC 容器？如何触发 BFC 容器？BFC 容器可以解决哪些问题？
- CSS 中的伪类和伪元素有什么区别？
- flex 布局的核心属性（容器和项目），如何用 flex 实现两端对齐、平均分布？
- 如何实现水平垂直居中？
- 如何清除浮动？
- 响应式布局的实现方案有哪些？
- 什么是 CSS 预处理器？
- 什么是 CSS 变量？

## JavaScript

- JavaScript 的 7 种基本数据类型和 1 种引用数据类型分别是什么？它们的区别是什么？
- null 和 undefined 的区别是什么？在哪些场景下会返回 undefined？
- 什么是闭包？闭包的核心原理是什么？闭包有哪些应用场景？又会带来什么问题（内存泄漏）？
- 箭头函数与普通函数的区别是什么？
- 如何改变 this 的指向？（call、apply、bind）三者的区别是什么？
- 什么是同步任务和异步任务？异步任务分为哪两类（宏任务、微任务）？
- 常见的宏任务和微任务有哪些？事件循环（Event Loop）的执行机制是什么？
- Promise 的三种状态是什么？如何改变 Promise 的状态？Promise 的常用方法有哪些（then、catch、finally、all、race）？
- 什么是函数柯里化？
- async/await 是什么？它与 Promise 的关系是什么？如何用 async/await 处理异步错误？
- 数组的常用方法有哪些？（分别说明改变原数组和不改变原数组的方法）
- 如何实现数组去重？（至少 3 种方法，从简单到高效）
- 如何深拷贝一个对象 / 数组？（浅拷贝与深拷贝的区别，实现方法：JSON 方法、递归实现等）
- Object 的常用方法有哪些？（Object.keys、Object.values、Object.assign 等）
- 什么是原型和原型链？原型链的终点是什么？它的作用是什么？
- 什么是跨域？常见的跨域解决方案有哪些？（CORS、JSONP、代理等）

## VUE

- Vue 中 v-if 和 v-show 的区别是什么？各自的使用场景是什么？
- Vue 中常用的指令有哪些？（v-bind、v-on、v-model、v-for 等），v-model 的原理是什么？
- v-for 中为什么需要设置 key？key 的作用是什么？不设置 key 会有什么问题？
- Vue 中的计算属性（computed）和侦听器（watch）的区别是什么？各自的使用场景是什么？
- Vue 中组件之间的通信方式有哪些？（父子组件、兄弟组件、跨层级组件）
- Vue 中插槽（slot）的作用是什么？有哪些类型的插槽？（默认插槽、具名插槽、作用域插槽）
- 什么是动态组件？如何实现动态组件切换？（component 标签 + is 属性）
- Vuex 的核心组成部分有哪些？（State、Getter、Mutation、Action、Module）各自的作用是什么？
- Pinia 与 Vuex 的区别是什么？Pinia 的核心优势是什么？（Vue 3 推荐）
- 如何实现路由懒加载？路由懒加载的核心优势是什么？
- Vue 的响应式原理是什么？（Vue 2：Object.defineProperty，Vue 3：Proxy）两者的区别是什么？
- 什么是虚拟 DOM、diff 算法（快速 diff 算法：预处理、最大递增子序列）
- Vue 3 相比 Vue 2 有哪些核心升级？（Composition API、Teleport、Suspense、Vite 等）
- Vue 中的生命周期钩子有哪些？（Vue 2 与 Vue 3 对比）各自的执行时机和使用场景是什么？
- 如何优化 Vue 项目的性能？（从组件、路由、状态管理、打包等角度回答

## REACT

## HTML

- src 和 href 的区别

  - 加载：src 阻塞页面解析，href 不阻塞
  - 用途：src 是【嵌入/替换】资源，href 是【关联/链接】资源
  - 核心标签：src 对应`<script> <img>`,href 对应`<a> <link>`

- 页面引入外部脚本时，`defer`和`async`的区别

  - script 代码分两个部分：代码加载和代码执行
  - async 和 defer 都会异步下载过程，但 async 执行会在下载后阻塞执行，而 defer 会等页面加载后阻塞执行
  - 需要注意 defer 和 async 仅对加载的 script 有限，script 包裹代码无效

- 本地存储 localStorage 和 sessionStorage 的区别

  - localStorage：持久化存储（同域名所有标签）、存储大小 6M
  - sessionStorage：会话级存储（仅当前标签）、存储大小 4KB

  ## CSS

- 什么是 CSS 盒模型？标准盒模型和 IE 盒模型有哪些区别？

  - CSS 盒模型，定义元素的排列规则
  - 标准盒模型：width（content）+padding+border+margin
  - IE 盒模型：content（content+padding+border）+margin
  - 标准盒模型转 IE 盒模型：`box-sizing:border-box`

- 什么是 BFC 容器？如何触发 BFC 容器？BFC 容器可以解决哪些问题？

  - BFC 容器：通俗易懂的理解，就是一个独立的隔离容器，因为是块容器所有元素垂直排列
  - 触发 BFC 容器：
    - 根元素：`<html>`
    - 浮动元素：float 属性不为 none（left、right）
    - 绝对定位、固定定位：postion 为 absolute、fixed
    - 溢出处理：overflow 属性部位 visible（hidden、auto、scroll）
    - 弹性盒子：dispaly 为 flex、inline-flex、grid、inline-grid
  - 解决哪些问题
    - 高度塌陷（浮动元素脱离文档流，父元素无高度）
    - margin 重叠、两个相邻的块级元素

- CSS 中的伪类和伪元素有什么区别？

  - 伪类：
    - 不会创建元素，对已经存在的元素进行筛选，如 a:hover、div:first-child、input:checked
    - 使用单个冒号
  - 伪元素：
    - 在元素前后或者内部生成一个全新的、不可见的虚拟元素（这个 DOM 元素不在虚拟树中，无法通过 DOM 获取），然后对这个元素进行样式设置，如 div::before、p::first-line、span::selection

- flex 布局的核心属性（容器和项目），如何用 flex 实现两端对齐、平均分布？

  - flex 容器（flex container）：给元素设置（display:flex/inline-flex），该元素则成为 flex 容器，其子元素成为 flex 项目。
    - flex-direction：控制主轴方向，默认 row，可以设置 column
    - flex-wrap：项目是否换行，默认是 nowrap，可以设置 wrap
    - justify-content:flex-start flex-end center flex-between(两端对齐) flex-space（平均分布）
    - align-item:flex-start flex-end center baseline（基线对齐）
  - flex 项目（flex item）：父元素设置了（display：flex/inline-flex）

- 如何实现水平垂直居中？

  - 弹性盒子：flex
  - 绝对定位+transform：position + transform
    - position:absolute；left:50%; right:50%; transform:translate(-50%,-50%);
  - 表格布局：dispaly:table-cell;vertical-align:center;text-align:center;

- 如何清除浮动？

  - 给父元素添加 BFC：overflow：hidden 或者 overflow：auto
  - 伪元素 clear：auto

- 响应式布局实现方案有哪些？

  - 百分比/rem/vm/vh/媒体查询
  - 移动端：`<meta name="viewport" content="width=device-width, initial-scale=1.0">`

  - 媒体查询基本语法：`@media screen and (min-width: 769px) and (max-width: 992px)`

- 什么是 CSS 预处理器？

  - scss/less：添加嵌套和变量
  - nocss：taiwindcss

- 什么是 CSS 变量？
  - CSS 变量是 CSS3 定义的新特性，允许开发者在 CSS 中定义可复用的数值或字符串，后续可在样式代码中多次引用，并且支持动态修改
  - 定义：全局定义,需要在`:root`（伪类）中定义变量`--main-color: #42b983;`,使用 var() 函数来引用已定义的 CSS 变量，局部定义则直接定义到元素中即可
  - 使用语法：`var(--变量名)`
  - JavaScript 使用：
    - 读取变量：getComputedStyle(元素).getPropertyValue('--变量名')
    - 修改 / 设置变量：元素.style.setProperty('--变量名', '变量值')

## JavaScript

- JavaScript 的 7 种基本数据类型和 1 种引用数据类型分别是什么？它们的区别是什么？

  - 基本数据类型：String Number Boolean Null Undefined Symbol BigInt
  - 引用数据类型：Object（Function、Array）

- null 和 undefined 的区别是什么？在哪些场景下会返回 undefined？

  - null：表示一个空对象
  - undefined：表示变量未定义

- 什么是闭包？闭包的核心原理是什么？闭包有哪些应用场景？又会带来什么问题（内存泄漏）？

  - 一个函数返回一个匿名函数，当执行这个函数，该函数执行完毕后作用域销毁，但是返回的匿名函数还存在
  - 节流和防抖可以使用闭包+apply 进行封装
  - 问题就是内存泄漏

- 箭头函数与普通函数的区别是什么？

  - 箭头函数通常用来改变 this 的执行问题，即指向上一层函数

- 如何改变 this 的指向？（call、apply、bind）三者的区别是什么？

  - call 参数是用逗号分割，返回的是一个结果
  - apply 参数是一个数组，返回的是一个结果
  - bind 参数是逗号风格，返回的是一个方法

- 什么是同步任务和异步任务？异步任务分为哪两类（宏任务、微任务）？

  - JavaScript 是单线程，所有分为同步任务和异步任务，同步任务会阻塞代码执行，异步不会。

- 常见的宏任务和微任务有哪些？事件循环（Event Loop）的执行机制是什么？

  - 宏任务：`<script> setTimeout setImmediate`
  - 微任务：`promise.resolve().then() await/async`
  - 事件循环机制：理解 script 标签代码怎么执行

- Promise 的三种状态是什么？如何改变 Promise 的状态？Promise 的常用方法有哪些（then、catch、finally、all、race）？

  - pendding -> fulfilled resolved
  - all 所有异步成功才成功
  - race 获取最快成功的一个返回值

- 函数柯里化？

  - 本质是将一个函数的多个参数更改为多个函数一个参数的链式结构
  - `(a,b,c) => (a)(b)(c)`

- async/await 是什么？它与 Promise 的关系是什么？如何用 async/await 处理异步错误？
  - 将函数封装成同步和异步
  - 本质是 Promise 的语法糖
  - 使用 result 返回值去做判断

## Vue

- Vue 3 相比 Vue 2 有哪些核心升级？（Composition API、Teleport、Suspense、Vite 等）

  - 响应式实现
  - 钩子函数：setup 函数本身在 beforeCreated 之前实现
  - composition API
  - 构建工具：vite 和 webpack

- Vue 中的生命周期钩子有哪些？（Vue 2 与 Vue 3 对比）各自的执行时机和使用场景是什么？

  - ComponentAPI：
    - 无对应
    - onBeforeMounted/onMounted
    - onBeforeUpload/onUpload
    - onBeforeUnMount/onUnMounted
  - OptionsAPI：
    - beforeCreated/create
    - beforeMounted/mounte
    - beforeUpload/upload
    - beoforeUnMount/unMounted（Vue3）beforeDestry/destried

- 如何优化 Vue 项目的性能？（从组件、路由、状态管理、打包等角度回答

  - 使用懒加载：减少 chunk 体积
  - 使用预加载：在首页 onMounted 通过 import 预先加载需要预览的组件
  - 使用 pinia/本次存储进行缓存处理
  - 开启生产环境压缩：删除注解、自动压缩图片
  - TreeShaking（打包工具自动剔除未引用的代码）
  - 第三方库：按需加载

  - 总结：
    - 减少加载：通过路由懒加载、打包优化、CDN 引入，减小首屏 / 资源加载体积，提升加载速度。
    - 减少渲染：通过组件缓存、响应式优化、避免冗余表达式，减少不必要的组件渲染 / 更新。
    - 提升效率：通过精简状态、优化第三方库、避免内存泄漏，提升项目运行时的流畅性。

  对于大多数项目，优先落地「路由懒加载」「<keep-alive> 缓存」「Tree-Shaking」「第三方库按需导入」这几个低成本、高收益的优化方案，再通过打包分析工具定位瓶颈，进行针对性优化。
